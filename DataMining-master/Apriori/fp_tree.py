# -*- coding: utf-8 -*-
"""FP-Tree.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/11WNXQ8BO7jiblpRAuYhS9WfdNaXy8LQq
"""

#@title 默认标题文本
import itertools
class MyList(list):
  '''
  用于给 list 添加 hash属性，使之能作为 dict 的 key 值
  '''
  """比普通的list多一个__hash__方法"""
  def __hash__(self):
    # 不能返回hash(self)
    # hash(self)会调用self的本方法，再调用回去，那就没完了(RecursionError)
    # 用的时候要注意实例中至少有一个元素，不然0怎么取(IndexError)
    return hash(self[0])

def ImportData():
  '''产生数据集'''
  data = [['f','a','c','d','g','i','m','p'],
        ['a','b','c','f','l','o'],
        ['b','f','h','j','m','p'],
        ['b','c','k','m','o','s'],
        ['a','f','c','e','l','n','o','p']]
  return data

def Data_Num(data):
  '''给项目集计数,计算每个种类的个数'''
  ds = {}
  for i in data:
    for pk in i:
      if pk not in ds:
        ds[pk] = 0
      ds[pk] += 1
  return ds

def Data_Sort(data,data_num,min_support):
  '''根据种类数量重新对项目集进行排序, 并删除支持数小于 min_support 的类别'''
  p = []
  for i in data:
    dic = {}
    for pk in i:
      dic[pk] = data_num[pk]
    list1= sorted(dic.items(),key=lambda x:x[1],reverse=True)
    kk = []
    for k in list1:
      if k[1] >= 3:
        kk.append(k[0])
    p.append(kk)
  return p

class Node:
  def __init__(self,char,val):
    self.char = char # 属性
    self.val = val # 节点计数
    self.children = {} # 存放孩子节点
    self.father = None # 父节点
    self.next = None # 用于链表，连接下一个节点
    self.visit = 0 # 用于记录该节点是否已经被访问
    self.links = {}
    self.links1 = {}

class FP_Tree():
  def __init__(self,data):
    self.data = data
    self.root = Node('root',-1)

  def Build_Tree(self):
    data = self.data
    #root = Node('root',-1)
    for lines in data:
      root = self.root
      for it in lines:
        if it not in root.children.keys(): # 如果不在孩子当中
          root.children[it] = Node(it,1) # 添加进入孩子当中，新增一个节点
          root.children[it].father = root # 设置为孩子节点的父节点
        else:
          root.children[it].val += 1
        root = root.children[it]

        if it in self.root.links.keys(): # 如果这个属性已经在 links 中存在了
          if root.visit == 0: # 如果该节点没有被访过
            #if root not in self.root.links[it]:
            self.root.links[it].append(root)
            self.root.links1[it].append(root)
            root.visit = 1 
        else: # 如果这个属性在links不存在
          self.root.links[it] = []
          self.root.links[it].append(root)
          self.root.links1[it] = []
          self.root.links1[it].append(root)
          visit = 1
        
        
    print("\nFP-Tree建立完成!\n\n")
    return self.root

  def Growth(self,pk,min_support):
    #print(pk)
    char_sup = []
    for ns in self.root.links[pk]:
      node = ns.father
      lines = []
      while node.char != 'root':
        lines.append(node.char)
        node = node.father
      if lines:
        char_sup.append(lines)
    #print(char_sup)

    # 计算条件FP-Tree
    pre_tree = {}
    pl = []
    for po in char_sup[0]:
      flags = 0
      for i in char_sup:
        if po in i:
          flags += 1
      if flags == len(char_sup):
        pl.append(po)
    if pl:
      pre_tree = (pl,len(char_sup))
    # 输出条件树
    #print("条件树")
    print(pk + '--->' + str(pre_tree))

    # 计算产生的频繁模式
    sup_set = {}
    if pre_tree:
      pre_tree[0].append(pk)
      for i in range(1,len(pre_tree[0])+1):
        itts = itertools.combinations(pre_tree[0],i)
        #print(list(itts))
        if pre_tree[1] >= min_support:
          for k in list(itts):
            if len(k) > 1:
              if pk in k:
                sup_set[MyList(k)] = pre_tree[1]
    
    if sup_set:
      return sup_set
    else:
      return


if __name__ == '__main__':
  # 最小支持数 设置为3
  min_support = 3
  data = ImportData()
  data_num = Data_Num(data)
  data_su = {} # 用于项头表
  for i in data_num:
    if data_num[i] >= 3:
      data_su[i] = data_num[i]

  # print(data_su)

  print("原始数据集为：")
  for pk in data:
    print(pk)
  
  # 整理数据
  data_s = Data_Sort(data,data_num,min_support)
  print("\n整理后的数据集为：")
  for pk in data_s:
    print(pk)
  
  # 建立FP-Tree
  fp = FP_Tree(data_s)
  root = fp.Build_Tree()

  # 根据项头表来查找频繁集
  print(data_su)
  supset = [] # 最终频繁模式
  for pk in data_su:
    print("条件树：")
    sup = fp.Growth(pk,min_support)
    if sup:
      supset.append(sup)
  
  print("\n最终频繁模式：")
  print(supset)
  #print(root.links)
