# -*- coding: utf-8 -*-
"""Close.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1thRIYA2HpaxkBdTWg2oGm_6HQ87eZTy5
"""

import itertools

# 所有不重复的闭合
fc = []
# 频繁项目集
l = []

class MyList(list):
  '''
  用于给 list 添加 hash属性，使之能作为 dict 的 key 值
  '''
  """比普通的list多一个__hash__方法"""
  def __hash__(self):
    # 不能返回hash(self)
    # hash(self)会调用self的本方法，再调用回去，那就没完了(RecursionError)
    # 用的时候要注意实例中至少有一个元素，不然0怎么取(IndexError)
    return hash(self[0])

def GetData():
  '''获取数据'''
  data = [['A','B','E'],
        ['B','D'],
        ['B','C'],
        ['A','B','D'],
        ['A','C'],
        ['B','C'],
        ['A','C'],
        ['A','B','C','E'],
        ['A','B','C']]
  return data

class A_Close:
  def __init__(self,data,min_sup):
    self.data = data
    self.min_sup = min_sup
    self.fc = []
    self.l = []
    self.fc_table = []

  def Close(self):
    data = self.data
    min_up = self.min_sup
    # 计算FCC1
    all_item = set(data[0])
    for i in data:
      all_item.update(i)
    #print(all_item)

    # 计算 FCC1 的闭合与支持度
    fcc1 = {}
    for i in all_item:
      # print(i)
      cha = []
      for k in data:
        if i in k:
          cha.append(k)
      #print(cha)
      kc = set(cha[1])
      for k in cha:
        kc = kc.intersection(set(k))
      #print(kc)
      if (len(cha)) >=2:
        print(str(set(i))+"---->"+str(kc)+"---->"+str(len(cha)))
        fcc1[MyList(list(kc))] = len(cha)
        self.fc_table.append([set(i),kc])
    
    self.fc = set(fcc1)
    self.l = set(all_item)
    #return fc,l
  
  def Gen(self,gen,g_num):
    data = self.data
    # 得到候选项
    set1 = itertools.combinations(gen,g_num)
    set2 = []
    for i in set1:
      for k in data:
        if set(i) <= set(k):
          set2.append(i)
    #print(set(set2))
    # 检查候选项是否是闭包的子集
    set3 = []
    for i in set(set2):
      for k in self.fc_table:
        if set(i) < k[1] and k[0] <= set(i):
          set3.append(i)
    #print(set3)
    set2 = set(set2)
    for i in set3:
      set2.remove(i)
    #print(set2)
    # 检查支持数并挑选合格的generator
    for i in set2:
      fla = []
      for k in data:
        if set(i) <= set(k):
          fla.append(k)
      #print(str(i)+"--->"+str(fla))
      pk = set(fla[0])
      for k in fla:
        pk = pk.intersection(k)
      print(str(set(i))+"---->"+str(pk)+"---->"+str(len(fla)))
      if len(fla) >=2 :
        self.fc_table.append([set(i),pk])
    #print(self.fc_table)

if __name__ == '__main__':
  # 最小支持度 为 2
  min_sup = 2
  data = GetData()
  print("源数据为：")
  for i in data:
    print(i)
  print()
  
  print("FCC1:")
  ac = A_Close(data,min_sup)
  ac.Close()
  
  #print(ac.fc)
  #print(ac.l)
  #print(ac.fc_table)
  
  for i in range(2,5):
    print("\nFCC"+str(i)+":")
    ac.Gen(ac.l,i)
  print()
  print(ac.fc_table)

  val = []
  for pk in ac.fc_table:
    val.append(pk[1])
  print(val)
  
  for i in range(5,0,-1):
    print("L"+str(i)+":")
    fac = []
    for k in val:
      if len(k) == i:
        if k not in fac:
          fac.append(k)
    print(fac)
    for k in fac:
      lc = itertools.combinations(k,i-1)
      for ji in set(lc):
        if set(ji) not in val:
          val.append(set(ji))

